(window.webpackJsonp=window.webpackJsonp||[]).push([[99],{583:function(t,_,a){"use strict";a.r(_);var v=a(5),e=Object(v.a)({},(function(){var t=this,_=t.$createElement,a=t._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"nagle-算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nagle-算法"}},[t._v("#")]),t._v(" Nagle 算法")]),t._v(" "),a("p",[t._v("试想一个场景，发送端不停地给接收端发很小的包，一次只发 1 个字节，那么发 1 千个字节需要发 1000 次。这种频繁的发送是存在问题的，不光是传输的时延消耗，发送和确认本身也是需要耗时的，频繁的发送接收带来了巨大的时延。")]),t._v(" "),a("p",[t._v("而避免小包的频繁发送，这就是 Nagle 算法要做的事情。")]),t._v(" "),a("p",[t._v("具体来说，Nagle 算法的规则如下:")]),t._v(" "),a("ul",[a("li",[t._v("当第一次发送数据时不用等待，就算是 1byte 的小包也立即发送")]),t._v(" "),a("li",[t._v("后面发送满足下面条件之一就可以发了:\n"),a("ul",[a("li",[t._v("数据包大小达到最大段大小(Max Segment Size, 即 MSS)")]),t._v(" "),a("li",[t._v("之前所有包的 ACK 都已接收到")])])])]),t._v(" "),a("h2",{attrs:{id:"延迟确认"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#延迟确认"}},[t._v("#")]),t._v(" 延迟确认")]),t._v(" "),a("p",[t._v("试想这样一个场景，当我收到了发送端的一个包，然后在极短的时间内又接收到了第二个包，那我是一个个地回复，还是稍微等一下，把两个包的 ACK 合并后一起回复呢？")]),t._v(" "),a("p",[a("strong",[t._v("延迟确认")]),t._v("(delayed ack)所做的事情，就是后者，稍稍延迟，然后合并 ACK，最后才回复给发送端。TCP 要求这个延迟的时延必须小于500ms，一般操作系统实现都不会超过200ms。")]),t._v(" "),a("p",[t._v("不过需要主要的是，有一些场景是不能延迟确认的，收到了就要马上回复:")]),t._v(" "),a("ul",[a("li",[t._v("接收到了大于一个 frame 的报文，且需要调整窗口大小")]),t._v(" "),a("li",[t._v("TCP 处于 quickack 模式（通过"),a("code",[t._v("tcp_in_quickack_mode")]),t._v("设置）")]),t._v(" "),a("li",[t._v("发现了乱序包")])]),t._v(" "),a("h2",{attrs:{id:"两者一起使用会怎样"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#两者一起使用会怎样"}},[t._v("#")]),t._v(" 两者一起使用会怎样？")]),t._v(" "),a("p",[t._v("前者意味着延迟发，后者意味着延迟接收，会造成更大的延迟，产生性能问题。")])])}),[],!1,null,null,null);_.default=e.exports}}]);